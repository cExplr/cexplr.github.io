<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Angr-CTF #1 - Basic Concepts, find and avoid - cExplr&#x27;s Blog</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../0_home.html">Home</a></li><li class="chapter-item expanded affix "><a href="../../research/1_ASUSWRT_3_0_0_4_384_20308.html">ASUSWRT URL Processing Stack Buffer Overflow</a></li><li class="chapter-item expanded affix "><a href="../../writeups/service_revolution/2_AllesCTF_service_revolution.html">AllesCTF 2020 - Service Revolution</a></li><li class="chapter-item expanded affix "><a href="../../writeups/angr/3_angr_post_1.html" class="active">Angr-CTF #1 - Basic Concepts, find and avoid</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">cExplr&#x27;s Blog</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#angr-ctf-1-basic-concepts---00_angr_find---01_angr_avoid" id="angr-ctf-1-basic-concepts---00_angr_find---01_angr_avoid">Angr-CTF #1 (Basic Concepts -&gt; 00_angr_find -&gt; 01_angr_avoid)</a></h1>
<hr />
<p><img src="img/angrLogo.jpg" alt="angrLogo.jpg" /></p>
<p>This writeup attempts to start from the basic concepts in the first few challenges before getting more detailed in the later challenges.</p>
<h2><a class="header" href="#description" id="description"><strong>Description</strong></a></h2>
<p>Angr is a python framework that is used for binary analysis by combining both static and dynamic symbolic analysis. There are many usages of this framework including in CTFs like ROPChaining, SMT solving (z3 as backend) and others. For this post(s), it is meant to be a more detailed writeup on the challenges with reference to the angr API. You can find the challenges from <a href="https://github.com/jakespringer/angr_ctf">https://github.com/jakespringer/angr_ctf</a>. It includes the solution and scaffolds [ helper code structure ] to aid in learning angr.</p>
<p>You can view Angr's documentations from <a href="http://angr.io/api-doc/">http://angr.io/api-doc/</a></p>
<h2><a class="header" href="#what-is-symbolic-execution" id="what-is-symbolic-execution">What is Symbolic Execution</a></h2>
<h1><a class="header" href="#" id=""></a></h1>
<p>WIKIPEDIA SAYS:</p>
<blockquote>
<p>In computer science, symbolic execution (also symbolic evaluation or symbex) is a means of analyzing a program to determine what inputs cause each part of a program to execute. An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would. It thus arrives at expressions in terms of those symbols for expressions and variables in the program, and constraints in terms of those symbols for the possible outcomes of each conditional branch. </p>
</blockquote>
<p>This allows us to &quot;follow&quot; marked variables/registers/memory and see what changes during the execution of the program which makes it useful for binary analysis. Coupled with a SMT solver like Z3 solver, we can solve values based on constraints that can be added by the user based on the program's analysis.</p>
<hr />
<h2><a class="header" href="#installing-angr" id="installing-angr"><strong>Installing Angr</strong></a></h2>
<p>You can choose to install and setup a virtualenv be it a virtual machine or via python's <code>mkvirtualenv</code> command.</p>
<p>Installing angr via pip would be as easy as :</p>
<pre><code>pip install angr
</code></pre>
<p>For me, I am doing it in a ubuntu18 VM with python3 and relied mostly on the documentations and ipython3. You can install ipython3 via pip as well. What's amazing is that you can generate variants of the challenges with their generate.py file and it would generate c code before compiling it with GCC. For this writeups, I will be using the binary under the <code>dist</code> folder with IDA as our decompiler. You can choose to use Ghidra as well and their symbols should still be intact since these 32bits binaries are not stripped of their symbols.</p>
<hr />
<h2><a class="header" href="#00_angr_find" id="00_angr_find"><strong>00_angr_find</strong></a></h2>
<p>Since this is the first challenge, there will be a little more details on some of the components of Angr that I hope is sufficient to help us understand how to use the basics of Angr. There will be examples of usages of some of the key components which can also be lifted off the documentations. As we visit more challenges, only the critical part would be covered so bear with me for this first one.</p>
<h3><a class="header" href="#the-decompilation" id="the-decompilation"><strong>The decompilation</strong></a></h3>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  signed int i; // [esp+1Ch] [ebp-1Ch]
  char s1[9]; // [esp+23h] [ebp-15h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  printf(&quot;Enter the password: &quot;);
  __isoc99_scanf(&quot;%8s&quot;, s1);
  for ( i = 0; i &lt;= 7; ++i )
    s1[i] = complex_function(s1[i], i);
  if ( !strcmp(s1, &quot;JACEJGCS&quot;) )
    puts(&quot;Good Job.&quot;);
  else
    puts(&quot;Try again.&quot;);
  return 0;
}
</code></pre>
<p>The main function is short and simple. It gets the user input from stdin. It only requires 8 bytes as password and for each of teh eight characters, a <code>complex_function</code> is applied to it. At the end of the day, those manupulations should cause the <code>password</code> to be transformed into <code>JACEJGCS</code> before printing a good job message which is the goal of this exercise.</p>
<p>Let's check out the <code>complex_function</code>.</p>
<pre><code class="language-c">int __cdecl complex_function(signed int a1, int a2)
{
  if ( a1 &lt;= 64 || a1 &gt; 90 )
  {
    puts(&quot;Try again.&quot;);
    exit(1);
  }
  return (3 * a2 + a1 - 65) % 26 + 65;
}}
</code></pre>
<p>This complex function takes in two arguments. The first argument would be the <code>s[i]</code> which is the user's input at the i-th index and the second argument would be the i-index itself. It checks that they are ASCII printable characters before doing some sort of transformation to it, specifically <code>(3 * a2 + a1 - 65) % 26 + 65</code>, before returning that value.</p>
<h3><a class="header" href="#creating-new-project" id="creating-new-project"><strong>Creating new Project</strong></a></h3>
<p>To start, lets fire up ipython3 and import Angr. It might take a little while to import at first.</p>
<pre><code class="language-python">import angr
</code></pre>
<p>The next step would be to create a new project. Referencing <a href="http://angr.io/api-doc/">http://angr.io/api-doc/</a>, we can go to the <code>Project</code> to see what arguments are being accepted.</p>
<pre><code class="language-python">class angr.project.Project(thing, default_analysis_mode=None, ignore_functions=None, use_sim_procedures=True, exclude_sim_procedures_func=None, exclude_sim_procedures_list=(), arch=None, simos=None, engine=None, load_options: Dict[str, Any] = None, translation_cache=True, support_selfmodifying_code=False, store_function=None, load_function=None, analyses_preset=None, concrete_target=None, **kwargs)
</code></pre>
<p>also, according to document, any other additional keywords will be passed into the <code>cle.loader</code>. CLE refers to the binary loader that angr use to be placed into memory almost like how the binary would be loaded when the binary is being run. This also means that the arguments used in this following loader class can be placed into the Project arguments as a fast way to configure the project and the loader at the same time.</p>
<pre><code class="language-python">class cle.loader.Loader(main_binary, auto_load_libs=True, concrete_target=None, force_load_libs=(), skip_libs=(), main_opts=None, lib_opts=None, ld_path=(), use_system_libs=True, ignore_import_version_numbers=True, case_insensitive=False, rebase_granularity=1048576, except_missing_libs=False, aslr=False, perform_relocations=True, load_debug_info=False, page_size=1, preload_libs=(), arch=None)
</code></pre>
<p>For this binary, we can set the settings to its default and just passing in the <code>thing</code>, basically the path to the binary for the Project instantiation.</p>
<pre><code class="language-python">project = angr.Project(&quot;./00_angr_find&quot;)
</code></pre>
<h3><a class="header" href="#loader" id="loader"><strong>Loader</strong></a></h3>
<p>Learn more about the loader from <a href="https://docs.angr.io/core-concepts/loading">https://docs.angr.io/core-concepts/loading</a>. In short, cited from this site:</p>
<blockquote>
<p>The CLE loader (cle.Loader) represents an entire conglomerate of loaded binary objects, loaded and mapped into a single memory space. Each binary object is loaded by a loader backend that can handle its filetype (a subclass of cle.Backend). For example, cle.ELF is used to load ELF binaries.</p>
</blockquote>
<p>We can explore more with the loader.</p>
<pre><code>loader = project.loader
</code></pre>
<p><img src="img/exploreLoader.jpg" alt="exploreLoader.jpg" /></p>
<p>Also, we can see the main object which reveals things like it's section, PLT, architecture and things like whether Position Independent Code is present.</p>
<pre><code>In [10]: mainobj.pic
Out[10]: False

In [11]: mainobj.arch
Out[11]: &lt;Arch X86 (LE)&gt;

In [12]: mainobj.plt
Out[12]: 
{'__gmon_start__': 134513728,
 '__isoc99_scanf': 134513712,
 '__libc_start_main': 134513696,
 '__stack_chk_fail': 134513648,
 'exit': 134513680,
 'printf': 134513632,
 'puts': 134513664,
 'strcmp': 134513616}
</code></pre>
<p>Also, we can just leave the loader as it is.</p>
<h3><a class="header" href="#the-solver-engine" id="the-solver-engine"><strong>The Solver Engine</strong></a></h3>
<p>In Angr, we can use &quot;mark&quot; things like variables, memory and registers. Angr uses <code>claripy</code> as backend for that purpose. Here, we can also use claripy as a frontend to Z3 to solve simple constraints. We can see the example at <a href="http://angr.io/api-doc/claripy.html">http://angr.io/api-doc/claripy.html</a>.</p>
<pre><code class="language-python">import claripy
a = claripy.BVS(&quot;sym_val&quot;, 32)
b = claripy.RotateLeft(a, 8)
c = b + 4
s = claripy.Solver()
s.add(c == 0x41424344)
assert s.eval(c, 1)[0] == 0x41424344
assert s.eval(a, 1)[0] == 0x40414243
</code></pre>
<p>When we work with claripy in angr, we can also use it to &quot;mark&quot; values at given state. In Agnr, the state is also referred to as <code>angr.sim_state.SimState</code> or just <code>SimState</code>. We can get a state via <code>project.factory</code>. <code>project.factory</code> contains several constructors for common object that are frequently used like getting basic blocks of code from a specified address and also states!</p>
<h3><a class="header" href="#states" id="states"><strong>States</strong></a></h3>
<p>There are several states that are available to get from the loaded binary and those states can be customized through arguments in those constructors.
The following table is lifted off from <a href="https://docs.angr.io/core-concepts/states">https://docs.angr.io/core-concepts/states</a></p>
<table><thead><tr><th>States</th><th>Description</th></tr></thead><tbody>
<tr><td>.blank_state()</td><td>Constructs 'blank state' with most of the data uninitialized.When accessing uninitialized data, an unconstrained symbolic value will be returned.</td></tr>
<tr><td>.entry_state()</td><td>constructs a state ready to execute at the main binary's entry point.</td></tr>
<tr><td>.full_init_state()</td><td>constructs a state that is ready to execute through any initializers that need to be run before the main binary's entry point, for example, shared library constructors or preinitializers.</td></tr>
<tr><td>.call_state()</td><td>constructs a state ready to execute a given function.</td></tr>
</tbody></table>
<p>For this binary, we only need to get the entry state.</p>
<details>
<summary>
Click here to see the help page for entry_state
</summary>
<pre><code>
In [16]: state = project.factory.entry_state?
Signature: project.factory.entry_state(**kwargs) -&gt; angr.sim_state.SimState
Docstring:
Returns a state object representing the program at its entry point. All parameters are optional.

:param addr:            The address the state should start at instead of the entry point.
:param initial_prefix:  If this is provided, all symbolic registers will hold symbolic values with names
                        prefixed by this string.
:param fs:              a dictionary of file names with associated preset SimFile objects.
:param concrete_fs:     boolean describing whether the host filesystem should be consulted when opening files.
:param chroot:          a path to use as a fake root directory, behaves similar to a real chroot. used only when
                        concrete_fs is set to True.
:param argc:            a custom value to use for the program's argc. May be either an int or a bitvector. If
                        not provided, defaults to the length of args.
:param args:            a list of values to use as the program's argv. May be mixed strings and bitvectors.
:param env:             a dictionary to use as the environment for the program. Both keys and values may be
                        mixed strings and bitvectors.
:return:                The entry state.
:rtype:                 SimState
File:      ~/.local/lib/python3.6/site-packages/angr/factory.py
Type:      method
</code></pre>
</details>
<p>Since we are not dealing with argc and argv, we can ignore those parameters. These will be especailly useful when we want to &quot;mark&quot; those values.</p>
<pre><code>In [18]: state = project.factory.entry_state()

In [19]: state
Out[19]: &lt;SimState @ 0x8048450&gt;
</code></pre>
<h3><a class="header" href="#simulation-manager" id="simulation-manager"><strong>Simulation Manager</strong></a></h3>
<p>Simulation Manager simulates the flow of the program. This also allows us to move from one state to the other starting from the state that we constructed at the beginning. It is also the primary interface in Angr for performing execution, simulation with states. For example, it allows you to step forward, filter, merge and move around as you wish. This simulation manager can contain several <code>staashes</code> of states. The default stash is known as  <code>active</code>.</p>
<pre><code>In [23]: simmgr = p.factory.simulation_manager?
Signature: p.factory.simulation_manager(thing:Union[List[angr.sim_state.SimState], angr.sim_state.SimState, NoneType]=None, **kwargs) -&gt; 'SimulationManager'
)
In [26]: simmgr = p.factory.simulation_manager(state)

In [27]: simmgr
Out[27]: &lt;SimulationManager with 1 active&gt;

In [28]: simmgr.active
Out[28]: [&lt;SimState @ 0x8048450&gt;]

In [29]: len(simmgr.active)
Out[29]: 1

In [30]: simmgr.active[0]
Out[30]: &lt;SimState @ 0x8048450&gt;

</code></pre>
<p>Here, we can start also access the state's register and memory as well. For example if we want to find the value of the instruction pointer.</p>
<pre><code>In [31]: initialstate = simmgr.active[0]
In [32]: initialstate.regs.eip
Out[32]: &lt;BV32 0x8048450&gt;
</code></pre>
<p>Now we can also start to explore the simulation manager more</p>
<p><img src="img/simulationManager.jpg" alt="simulationManager.jpg" /></p>
<p>One very useful function that we can use is the <code>explore</code> function. This allows us to run the program and let the program explore the binary. </p>
<pre><code>In [34]: simmgr.explore?
Signature: simmgr.explore(stash='active', n=None, find=None, avoid=None, find_stash='found', avoid_stash='avoid', cfg=None, num_find=1, **kwargs)
Docstring:
Tick stash &quot;stash&quot; forward (up to &quot;n&quot; times or until &quot;num_find&quot; states are found), looking for condition &quot;find&quot;,
avoiding condition &quot;avoid&quot;. Stores found states into &quot;find_stash' and avoided states into &quot;avoid_stash&quot;.

The &quot;find&quot; and &quot;avoid&quot; parameters may be any of:

- An address to find
- A set or list of addresses to find
- A function that takes a state and returns whether or not it matches.

If an angr CFG is passed in as the &quot;cfg&quot; parameter and &quot;find&quot; is either a number or a list or a set, then
any states which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.
File:      ~/.local/lib/python3.6/site-packages/angr/sim_manager.py
Type:      method
</code></pre>
<p>The one that we want to use is the find parameter. This allows us to state address(es) we want to find. To do that, we can go back to the disassembler to find an address that we want to hit.</p>
<p><img src="img/00_findaddress.jpg" alt="00_findaddress.jpg" /></p>
<p>Here is what it might look like when you explore the address that we want to find.</p>
<pre><code>In [35]: find = 0x08048678

In [36]: simmgr.explore(find=find)
WARNING | 2020-09-09 22:30:05,106 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.
WARNING | 2020-09-09 22:30:05,107 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:
WARNING | 2020-09-09 22:30:05,107 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state
...
...
...
Out[36]: &lt;SimulationManager with 1 active, 16 deadended, 1 found&gt;
</code></pre>
<p>We should now be able to see that there is one that is active and found. To see what is being found,</p>
<pre><code>In [40]: simmgr.found[0]
Out[40]: &lt;SimState @ 0x8048678&gt;
</code></pre>
<p>This means that there is a state where the program actually would hit that address that we desire which means that there is a satisfiable solution. Now all that we need to do is to dump the string that Angr wrote to the stdin. To do that, we will need to access the state and get the information about the os before dumping the string at the file descriptor.</p>
<pre><code>In [43]: import sys

In [44]: found = simmgr.found[0]

In [45]: found.posix.dumps(sys.stdin.fileno())
Out[46]: b'JXWVXRKX'
</code></pre>
<p>With that value being dumped out, we can now test that value. </p>
<h3><a class="header" href="#the-script" id="the-script"><strong>The Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys
# Create a new project with the following constructor
# The current default one is good enough for now
project = angr.Project(&quot;./00_angr_find&quot;)
# Construct the current state that we want to run from the main function
state = project.factory.entry_state()
# Construct our simulation manager based off the current state
simmgr = project.factory.simulation_manager(state)
# This is the address where the &quot;Good Job&quot; text would be printed out
find = 0x08048678
# Start the exploration to find the state whereby the input value would execute the selected find address
simmgr.explore(find=find)

if simmgr.found[0]:
    found = simmgr.found[0]
    print(&quot;Solution Found!&quot;)
    # print out the the stdin that angr has input and dump out the string from the file desciptor
    print(found.posix.dumps(sys.stdin.fileno()))
else:
    print(&quot;No solutions found! :&lt;&quot;)
</code></pre>
<p><img src="img/00_solved.jpg" alt="00_solved.jpg" /></p>
<hr />
<h2><a class="header" href="#01_angr_avoid" id="01_angr_avoid"><strong>01_angr_avoid</strong></a></h2>
<p>This challenge aims to show us about the avoid address which we can specify for Angr so that it would know that it is going down the wrong path and should retry. Like the <code>find</code> argument, we can also add the <code>avoid</code> argument as well in the <code>explore</code> function. Now, let's begin.</p>
<p>As usual, I tried opening the binary in IDA however there is a message by IDA saying that there are more than 1000 nodes to be displayed on the screen and that it failed to decompile because the function is too big. I have also tried to open it in Ghidra but it will take a very long time as well.</p>
<pre><code>cexplr@ubuntu:~/angr/angr_ctf-master/01_angr_avoid$ ls -alh output.c
-rw-r--r-- 1 cexplr cexplr 834K Sep 10 00:22 output.c
</code></pre>
<p>Just form the disassembly in IDA and Ghidra, we see that there are many checks and many <code>avoid_me</code> functions being called as well. We can edit the <code>generate.py</code> file in the challenge files outside of the <code>dist</code> folder.</p>
<pre><code class="language-python"># This is the new generate.py file to store a sample c code into an output.c file
#!/usr/bin/env pypy
import sys, random, os, tempfile
from templite import Templite

def generate(argv):
  if len(argv) != 3:
    print 'Usage: pypy generate.py [seed] [output_file]'
    sys.exit()

  seed = argv[1]
  output_file = argv[2]

  random.seed(seed)

  description = ''
  with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'description.txt'), 'r') as desc_file:
    description = desc_file.read().encode('string_escape').replace('\&quot;', '\\\&quot;')

  random_list = [random.choice([True, False]) for _ in xrange(64)]

  template = open(os.path.join(os.path.dirname(os.path.realpath(__file__)), '01_angr_avoid.c.templite'), 'r').read()
  c_code = Templite(template).render(description=description, random_list=random_list)

  with tempfile.NamedTemporaryFile(delete=False, suffix='.c') as temp:
    temp.write(c_code)
    f = open(&quot;output.c&quot;,&quot;w&quot;)
    f.write(c_code)
    f.close()
    temp.seek(0)
    os.system('gcc -m32 -o ' + output_file + ' ' + temp.name)

if __name__ == '__main__':
  generate(sys.argv)

</code></pre>
<p>We see that the file is huge.</p>
<p>To figure out why, we can look at the <code>01_angr_avoid.c.templite</code> file. THis is the recursive part which keeps adding checks and for each time it calls itself, it would also add c code  which thus makes it a super long check.</p>
<pre><code class="language-python">${
import random, os
random.seed(os.urandom(8))
userdef_charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
userdef = ''.join(random.choice(userdef_charset) for _ in range(8))

def check_string_recursive(array0, array1, random_list, bit):
  if bit &lt; 0:
    write('maybe_good(%s, %s);' % (array0, array1))
  else:
    if random_list[0]:
      write('if (CHECK_BIT(%s, %d) == CHECK_BIT(%s, %d)) {' % (array0, bit, array1, bit))
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('} else { avoid_me(); ')
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('}')
    else:
      write('if (CHECK_BIT(%s, %d) != CHECK_BIT(%s, %d)) { avoid_me();' % (array0, bit, array1, bit))
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('} else { ')
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('}')
}$
</code></pre>
<p>The output would look something like</p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;

#define USERDEF &quot;UFWSAIZV&quot;
#define LEN_USERDEF 8

// return true if nth bit of array is 1
#define CHECK_BIT(array, bit_index) (!!(((uint8_t*) array)[bit_index / 8] &amp; (((uint8_t) 0x1) &lt;&lt; (bit_index % 8))))

char msg[] =
  &quot;placeholder\n&quot;;

uint8_t should_succeed = 1;

void print_msg() {
  printf(&quot;%s&quot;, msg);
}

int complex_function(int value, int i) {
#define LAMBDA 5
  if (!('A' &lt;= value &amp;&amp; value &lt;= 'Z')) {
    printf(&quot;Try again.\n&quot;);
    exit(1);
  }
  return ((value - 'A' + (LAMBDA * i)) % ('Z' - 'A' + 1)) + 'A';
}

void avoid_me() {
  should_succeed = 0;
}

void maybe_good(char* compare0, char* compare1) {
  if (should_succeed &amp;&amp; !strncmp(compare0, compare1, 8)) {
    printf(&quot;Good Job.\n&quot;);
  } else {
    printf(&quot;Try again.\n&quot;);
  }
}

int main(int argc, char* argv[]) {
  char buffer[20];
  char password[20];

  //print_msg();

  for (int i=0; i &lt; 20; ++i) {
    password[i] = 0;
  }

  strncpy(password, USERDEF, LEN_USERDEF);

  printf(&quot;Enter the password: &quot;);
  scanf(&quot;%8s&quot;, buffer);

  for (int i=0; i&lt;LEN_USERDEF; ++i) {
    buffer[i] = (char) complex_function(buffer[i], i);
  }

...
...
...
...
...
...
if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { 
    avoid_me();
    maybe_good(buffer, password);} 
else { maybe_good(buffer, password);}
} 
else { 
    if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { 
        avoid_me();
        maybe_good(buffer, password);
    } else { 
        maybe_good(buffer, password);}
    }} 
        else { if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}}} else { if (CHECK_BIT(buffer, 2) != CHECK_BIT(password, 2)) { avoid_me();if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}} else { if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}}}}}}}}}}}}

</code></pre>
<p>Here we can see that after the user has input the password, it would go throught a complex function for each character.  After the input has been transformed, monstrous amount of checks are being done and anytime a check fails, it would set <code>should_succeed</code> to 0 which is in the <code>avoid_me</code> function. Additionally, with that number of checks, it is really <del>impossible</del> tedious to reverse and find out what value it should be in the end. So let's begin writing a script in angr.</p>
<p>Note that we know that there are many <code>avoid_me</code> functions that we should , of course, avoid. We can get those address from the disassembler. </p>
<p><img src="img/01_avoidme_functoin.jpg" alt="01_avoidme_functoin.jpg" /></p>
<p>We can also find the <code>maybe_good</code> function where the Good Job string would be printed.</p>
<p><img src="img/01_maybegood_function.jpg" alt="01_maybegood_function.jpg" /></p>
<h3><a class="header" href="#writing-the-script" id="writing-the-script"><strong>Writing the Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys

# Create the project and load the binary
project = angr.Project(&quot;./01_angr_avoid&quot;)

# Create a state based on the current loaded binary
state = project.factory.entry_state()

# Construct the simulation manager set with the current state
simmgr = project.factory.simulation_manager(state)

# Find the address to find and avoid
find = 0x80485e5
avoid = 0x80485a8

# Start exploring different inputs and hopefully find the find function that we want
simmgr.explore(find=find,avoid=avoid)

# if there is a solution,
if simmgr.found[0]:
    print(&quot;found a solution&quot;)
    # Print out the input that Angr had found
    print(simmgr.found[0].posix.dumps(sys.stdin.fileno()))
else:
    print(&quot;No found solutions&quot;)
</code></pre>
<h3><a class="header" href="#test-the-solution" id="test-the-solution"><strong>Test the solution</strong></a></h3>
<p>Run and test the output if any</p>
<p><img src="img/01_solved.jpg" alt="01_solved.jpg" /></p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../writeups/service_revolution/2_AllesCTF_service_revolution.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../writeups/service_revolution/2_AllesCTF_service_revolution.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
