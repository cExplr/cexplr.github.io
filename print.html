<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cExplr&#x27;s Blog</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0_home.html">Home</a></li><li class="chapter-item expanded affix "><a href="research/1_ASUSWRT_3_0_0_4_384_20308.html">ASUSWRT URL Processing Stack Buffer Overflow</a></li><li class="chapter-item expanded affix "><a href="writeups/service_revolution/2_AllesCTF_service_revolution.html">AllesCTF 2020 - Service Revolution</a></li><li class="chapter-item expanded affix "><a href="writeups/angr/3_angr_post_1.html">Angr-CTF #1 - Basic Concepts, Find and Avoid</a></li><li class="chapter-item expanded affix "><a href="writeups/angr/4_angr_post_2.html">Angr-CTF #2 - Find Conditions, Symbolic Registers and Stack</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">cExplr&#x27;s Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#welcome-to-cexplrs-blog" id="welcome-to-cexplrs-blog">Welcome to cExplr's Blog</a></h1>
<hr />
<p>This is where things that looks interesting to me are stored in, easy or hard ~</p>
<hr />
<p>Latest Post:</p>
<ul>
<li><a href="./writeups/angr/4_angr_post_2.html">Angr-CTF #2 - 02_angr_find_condition, 03_angr_symbolic_registers, 04_angr_symbolic_stack</a> - <em>11th September 2020</em></li>
<li><a href="./writeups/angr/3_angr_post_1.html">Angr-CTF #1 - Basic Concepts, 00_angr_find, 01_angr_avoid</a> - <em>10th September 2020</em></li>
<li><a href="./writeups/service_revolution/2_AllesCTF_service_revolution.html">AllesCTF 2020 - Service Revolution</a> - <em>7th September 2020</em></li>
<li><a href="./research/1_ASUSWRT_3_0_0_4_384_20308.html">ASUSWRT URL Processing Stack Buffer Overflow</a> - <em>7th August 2020</em></li>
</ul>
<hr />
<h1><a class="header" href="#asuswrt-url-processing-stack-buffer-overflow" id="asuswrt-url-processing-stack-buffer-overflow">ASUSWRT URL Processing Stack Buffer Overflow</a></h1>
<hr />
<h3><a class="header" href="#date--7th-august-2020" id="date--7th-august-2020">Date : 7th August 2020</a></h3>
<p>This is a blog post that details the Stack Buffer Overflow bug and how to exploit it and getting RCE.</p>
<blockquote>
<p>While processing the URL for any blacklisted XSS list like the script tag in the check_xss_blacklist function, a stack buffer overflow is possible by extending the length of the URL when accessing the web interface of the ASUS Router. To exploit it, stack pivoting technique is used before chaining up ROP gadgets to call our own custom command. In this post, we show how this can be exploited to get a reverse shell.</p>
</blockquote>
<blockquote>
<p>This vulnerability exists in routers that are using ASUSWRT 3.0.0.4.384.20308 (2018/02/01), and for our purposes, we used the RT-AC88U.</p>
</blockquote>
<p>Click <a href="https://starlabs.sg/blog/2020/08/asuswrt-url-processing-stack-buffer-overflow/">here</a> to get to the blogpost.</p>
<h1><a class="header" href="#rev-flag-service-revolution" id="rev-flag-service-revolution">[Rev] Flag Service Revolution</a></h1>
<h4><a class="header" href="#7-september-2020" id="7-september-2020">7 September 2020</a></h4>
<hr />
<h5><a class="header" href="#team--hats-singapore" id="team--hats-singapore">Team : HATS Singapore</a></h5>
<h5><a class="header" href="#challenge-files--a-hrefwriteupsservice_revolutionbootdolbootdola" id="challenge-files--a-hrefwriteupsservice_revolutionbootdolbootdola">Challenge File[s] : <a href="writeups/service_revolution/.//boot.dol">boot.dol</a></a></h5>
<h3><a class="header" href="#description" id="description">Description</a></h3>
<pre><code>Flag Service Revolution
Category: Reverse Engineering
Difficulty: Medium
Author: TheVamp, 0x4d5a
First Blood: LSE

Welcome to our great Flag{Service_Revolution}

Challenge Files:flag_service_revolution.7z
Feedback: Did you like the challenge? Thoughts? Give feedback here
</code></pre>
<h2><a class="header" href="#what-the-file" id="what-the-file">What The File?</a></h2>
<p>In this file, we are presented with mainly the boot.dol file. After a quick search on Google, we found <a href="https://www.file-extensions.org/dol-file-extension">this</a> link.</p>
<blockquote>
<p>DOL file extension - Nintendo GameCube executable.</p>
</blockquote>
<p>It also says that we can use <code>Dolphin</code> to work with *.dol files. </p>
<h2><a class="header" href="#dolphin-emulator" id="dolphin-emulator">DOLphin Emulator</a></h2>
<p>We then download the Dolphin emulator version 5 from <a href="https://dolphin-emu.org/download/">https://dolphin-emu.org/download/</a>. Next, click on File -&gt; Open... and select the <code>boot.dol</code> file.</p>
<p><img src="writeups/service_revolution/img/dolphin-emu-rundol.png" alt="rickrolling" /></p>
<p>Also, click on the <code>Controllers</code> icon. Make sure that the Wii Remote 1 is an <code>Emulated Wii Remote</code>. Click on configure to choose the choice of device, buttons and D-Pad. Once that is done, we can test our key input with the loaded game.</p>
<p><img src="writeups/service_revolution/img/checkkeypress.png" alt="keypressed" /></p>
<p>Note that there is also debugger built into the Dolphin Emulator though it is not really necessary.</p>
<h2><a class="header" href="#converting-the-dol-file-to-elf" id="converting-the-dol-file-to-elf">Converting the Dol file to ELF</a></h2>
<p>Throwing the dol file straight into Ghidra did not work. After a search <code>dol file in ghidra</code>, the first result points us to this <a href="https://hmapl.wordpress.com/2019/04/13/ghidra-a-potentially-useful-reverse-engineering-tool/">link</a>.</p>
<blockquote>
<p>Gamecube executables are typically in a DOL format. While this can, in theory be analyzed, itï¿½s much easier for Ghidra (and other tools) to analyze an ELF-format file.</p>
</blockquote>
<p>To do this, we can use a tool aptly called <a href="https://www.gc-forever.com/forums/viewtopic.php?t=17#p19">DolTool</a>. We will need to download the DolTool x0.3 - TenOfTen(LINUX) and compile it ourselves. Thankfully all it takes is <code>g++ -o ./doltool *cpp</code> and it should be compiled in no time. </p>
<p>Next run the following command.</p>
<pre><code>$ ./doltool -e boot.dol
DolTool v0.3 - loser 2003

Converted boot.dol to to boot.elf

$ file boot.elf 
boot.elf: ELF 32-bit MSB executable, PowerPC or cisco 4500, version 1 (SYSV), statically linked, stripped
</code></pre>
<p>This ELF should be recognizable by Ghidra.</p>
<h2><a class="header" href="#ghidraing-bootelf" id="ghidraing-bootelf">Ghidra'ing boot.elf</a></h2>
<p>The approach here is to do a strings to look for the <code>No flag yet...</code>. One of the functions referencing this string is <code>FUN_8003d4c4(void)</code>. </p>
<p>The decompilation is as follows</p>
<pre><code class="language-c">void FUN_8003d4c4(void)

{
...
&lt;REDACTED&gt;
...
  local_44 = DAT_803900a8;
  local_54 = s_Great_803900a0._4_2_;
  local_50 = DAT_803900ac;
  local_74 = s_{Service_Revolution}!_803900b4._4_4_;
  local_70 = s_{Service_Revolution}!_803900b4._8_4_;
  local_42 = DAT_803900aa;
  local_4c = DAT_803900b0;
  local_58 = s_Great_803900a0._0_4_;
  local_78 = s_{Service_Revolution}!_803900b4._0_4_;
  local_6c = s_{Service_Revolution}!_803900b4._12_4_;
  local_68 = s_{Service_Revolution}!_803900b4._16_4_;
  local_64 = s_{Service_Revolution}!_803900b4._20_2_;
  local_60 = s_Welcome_80390098._0_4_;
  local_5c = s_Welcome_80390098._4_4_;
  local_48 = 0x6f757200;
  local_120 = s_No_buttons_pressed_yet_..._800a7fc0._12_4_;
  local_11c = s_No_buttons_pressed_yet_..._800a7fc0._16_4_;
  local_118 = s_No_buttons_pressed_yet_..._800a7fc0._20_4_;
  local_114 = s_No_buttons_pressed_yet_..._800a7fc0._24_2_;
  local_112 = s_No_buttons_pressed_yet_..._800a7fc0[26];
  no_flag_yet_Str = s_No_flag_yet_..._800a7ff4._0_4_;
  local_de = 0x111;
  string_key_pressed = s_No_buttons_pressed_yet_..._800a7fc0._0_4_;
  local_128 = s_No_buttons_pressed_yet_..._800a7fc0._4_4_;
  local_124 = s_No_buttons_pressed_yet_..._800a7fc0._8_4_;
  local_15c = s_No_flag_yet_..._800a7ff4._4_4_;
  local_158 = s_No_flag_yet_..._800a7ff4._8_4_;
  local_154 = s_No_flag_yet_..._800a7ff4._12_4_;
  local_fb = 0;
  local_111 = 0;
  local_10d = 0;
  local_109 = 0;
  local_105 = 0;
  local_101 = 0;
  local_fd = 0;
  FUN_800971b4(auStack336,0,0x22);
  sequence = FUN_8003ebc4(auStack200,auStack404,PNG_801aa8e0,300,200);
  if (sequence == 0) {
    return;
  }
  iVar3 = 0xf;
  FLAG = &amp;no_flag_yet_Str;
  sequence = 0;
  FUN_80040594(auStack404,0x4c,0x3e);
  iVar2 = 0;
  iVar4 = 0x14;
  FUN_800406e4((double)DAT_803900cc,auStack404);
  local_16a = 0;
  FUN_8003eb1c();
  do {
    iVar1 = FUN_8003eb74();
    if (iVar1 == 0) {
      FUN_8003eba0(&amp;DAT_801d8f20,0x1b70d8);
    }
                    /* doesnt enter here
                        */
    if (DAT_8044b998 != 0) {
      FUN_8003eb54();
      FUN_80041db0(auStack200);
      FUN_80040458();
    }
    FUN_800568f4();
    if (DAT_8044b958 == 0) {
                    /* enters here
                        */
      iVar4 = iVar4 + ((uint)(DAT_8044b954 == 0) - 1);
      if (DAT_8044b950 == 0) goto LAB_8003d84c;
LAB_8003d74c:
      iVar3 = iVar3 + 1;
    }
    else {
      iVar4 = iVar4 + 1;
      if (DAT_8044b950 != 0) goto LAB_8003d74c;
LAB_8003d84c:
                    /* comes here */
      iVar3 = iVar3 + ((uint)(DAT_8044b94c == 0) - 1);
    }
    FUN_800993ec(auStack504,s_%s_%s_%s_%s_%s%s_80390084,&amp;local_60,&amp;local_44,&amp;local_48,&amp;local_58,
                 &amp;local_50,&amp;local_78);
    FUN_80040fd8(displayString,iVar4,iVar3,auStack504);
    key_code = get_keypress_FUN_800569b0(0);
    if (key_code != 0) {
      keypress_Strings_FUN_8003d2d4(key_code,(char *)&amp;string_key_pressed);
      if (sequence == 9) {
        if ((key_code &amp; 0x800) != 0) {
          FLAG = (undefined4 *)&amp;local_a0;
          local_8e = local_5c._2_1_;
          local_90 = local_6c._0_1_;
        }
LAB_8003d8e4:
        if (sequence == 0) {
LAB_8003d8ec:
          sequence = 0;
          if ((key_code &amp; 8) != 0) {
            sequence = 1;
            local_80 = (char)local_58;
            local_7e = local_78._1_1_ + ' ';
            local_81 = local_60._2_1_;
            local_a0 = (char)local_58 + -0x20;
            local_83 = local_70._0_1_;
          }
        }
      }
      else {
        if (sequence == 8) {
          if ((key_code &amp; 0x800) == 0) goto LAB_8003d8ec;
          local_93 = local_58._2_1_;
          sequence = 9;
          local_98 = local_68._0_1_;
        }
        else {
          if (sequence == 7) {
            if ((key_code &amp; 0x400) == 0) goto LAB_8003d8ec;
            sequence = 8;
            local_85 = (char)local_58;
            local_82 = local_50._0_1_ + ' ';
            local_92 = local_70._0_1_;
            local_8d = local_68._2_1_;
          }
          else {
            if (sequence == 6) {
              if ((key_code &amp; 0x400) == 0) goto LAB_8003d8ec;
              sequence = 7;
              local_7d = (undefined)local_68;
              local_9f = local_50._1_1_ + -0x20;
              local_9c = local_78._1_1_;
              local_95 = (undefined)local_44;
            }
            else {
              if (sequence == 5) {
                if ((key_code &amp; 0x100) == 0) goto LAB_8003d8ec;
                sequence = 6;
                local_7f = (undefined)local_50;
                local_9d = (char)local_74 + -0x20;
                local_7c = 0;
                local_91 = local_54._0_1_;
              }
              else {
                if (sequence == 4) {
                  if ((key_code &amp; 0x200) == 0) goto LAB_8003d8ec;
                  sequence = 5;
                  local_96 = local_50._1_1_;
                  local_88 = local_58._0_1_ + ' ';
                  local_8b = local_60._1_1_;
                  local_97 = local_70._0_1_;
                }
                else {
                  if (sequence == 3) {
                    if ((key_code &amp; 0x100) == 0) goto LAB_8003d8ec;
                    local_8a = local_58._1_1_;
                    sequence = 4;
                    local_8f = local_70._0_1_;
                    local_9b = local_78._0_1_;
                    local_89 = local_8f;
                  }
                  else {
                    if (sequence == 2) {
                      if ((key_code &amp; 0x200) == 0) goto LAB_8003d8ec;
                      sequence = 3;
                      local_94 = (undefined)local_70;
                      local_87 = local_70._1_1_ + ' ';
                      local_86 = (char)local_74;
                      local_99 = local_74._1_1_;
                    }
                    else {
                      if (sequence != 1) goto LAB_8003d8e4;
                      if ((key_code &amp; 4) == 0) goto LAB_8003d8ec;
                      sequence = 2;
                      local_84 = local_44._0_1_;
                      local_9e = local_6c._1_1_ + -0x20;
                      local_8c = (undefined)local_6c;
                      local_9a = local_60._0_1_;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    iVar2 = iVar2 + 1;
    key_code = (uint)local_16a;
    if ((uint)(iVar2 * -0x33333333) &lt; 0x33333334) {
      key_code = key_code + 1 &amp; 0xffff;
      if (key_code == 0x1b) {
        key_code = 0;
        local_16a = 0;
      }
      else {
        local_16a = (ushort)key_code;
      }
    }
    FUN_80040630(auStack404,(int)local_18c,(int)local_18a,key_code);
    FUN_80040fd8(displayString,0xf,100,&amp;string_key_pressed);
    FUN_80040fd8(displayString,0xf,0x82,FLAG);
    FUN_80040270();
  } while( true );
}
</code></pre>
<p>What this essentially is doing is to store the strings that we see in the running program like <code>No buttons pressed yet ...</code> and <code>No flag yet ...</code>. These will be printed out onto the screen first. In the game loop, it would check for keypresses in which it would also return some sort of keycode based on the buttons pressed which will allow the right strings to be printed. </p>
<p>It detects keypressed based on bitmasking. In summary, these are the bitmasking for each of the buttons.</p>
<pre><code>BITMASK  =  KEY PRESS
0x8 = A press 
0x4 = B press 
0x800 = up press 
0x400 = down press
0x100 = left press 
0x200 = right press 
0x1000 = + press
0x10 = - press 
0x1 = 1 press 
0x2 = 2 press
</code></pre>
<details>
<summary>
Click here to see the decompilation of keypress_Strings_FUN_8003d2d4
</summary>
<pre><code class="language-c">void keypress_Strings_FUN_8003d2d4(uint key_code,char *pressed_key)

{
  undefined4 uVar1;
  undefined2 uVar2;
  char cVar3;
  undefined4 uVar4;
  
  uVar2 = s_UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU_8038ffbc._68_2_;
  uVar1 = s_UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU_8038ffbc._64_4_;
  if ((key_code &amp; 8) != 0) {
    *(undefined4 *)pressed_key = s_UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU_8038ffbc._60_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined2 *)(pressed_key + 8) = uVar2;
  }
  uVar2 = s_Pressed_B_80390004._8_2_;
  uVar1 = s_Pressed_B_80390004._4_4_;
  if ((key_code &amp; 4) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_B_80390004._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined2 *)(pressed_key + 8) = uVar2;
  }
  cVar3 = s_Pressed_UP_80390010[10];
  uVar2 = s_Pressed_UP_80390010._8_2_;
  uVar1 = s_Pressed_UP_80390010._4_4_;
  if ((key_code &amp; 0x800) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_UP_80390010._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined2 *)(pressed_key + 8) = uVar2;
    pressed_key[10] = cVar3;
  }
  cVar3 = s_Pressed_DOWN_8039001c[12];
  uVar4 = s_Pressed_DOWN_8039001c._8_4_;
  uVar1 = s_Pressed_DOWN_8039001c._4_4_;
  if ((key_code &amp; 0x400) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_DOWN_8039001c._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined4 *)(pressed_key + 8) = uVar4;
    pressed_key[0xc] = cVar3;
  }
  cVar3 = s_Pressed_LEFT_8039002c[12];
  uVar4 = s_Pressed_LEFT_8039002c._8_4_;
  uVar1 = s_Pressed_LEFT_8039002c._4_4_;
  if ((key_code &amp; 0x100) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_LEFT_8039002c._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined4 *)(pressed_key + 8) = uVar4;
    pressed_key[0xc] = cVar3;
  }
  uVar2 = s_Pressed_RIGHT_8039003c._12_2_;
  uVar4 = s_Pressed_RIGHT_8039003c._8_4_;
  uVar1 = s_Pressed_RIGHT_8039003c._4_4_;
  if ((key_code &amp; 0x200) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_RIGHT_8039003c._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined4 *)(pressed_key + 8) = uVar4;
    *(undefined2 *)(pressed_key + 0xc) = uVar2;
  }
  cVar3 = s_Pressed_PLUS_8039004c[12];
  uVar4 = s_Pressed_PLUS_8039004c._8_4_;
  uVar1 = s_Pressed_PLUS_8039004c._4_4_;
  if ((key_code &amp; 0x1000) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_PLUS_8039004c._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined4 *)(pressed_key + 8) = uVar4;
    pressed_key[0xc] = cVar3;
  }
  uVar2 = s_Pressed_MINUS_8039005c._12_2_;
  uVar4 = s_Pressed_MINUS_8039005c._8_4_;
  uVar1 = s_Pressed_MINUS_8039005c._4_4_;
  if ((key_code &amp; 0x10) != 0) {
    *(undefined4 *)pressed_key = s_Pressed_MINUS_8039005c._0_4_;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    *(undefined4 *)(pressed_key + 8) = uVar4;
    *(undefined2 *)(pressed_key + 0xc) = uVar2;
  }
  uVar2 = s_Pressed_1_8039006c._8_2_;
  uVar1 = s_Pressed_1_8039006c._4_4_;
  if ((key_code &amp; 2) == 0) {
    if ((key_code &amp; 1) == 0) {
      return;
    }
  }
  else {
    *(undefined4 *)pressed_key = s_Pressed_1_8039006c._0_4_;
    *(undefined2 *)(pressed_key + 8) = uVar2;
    *(undefined4 *)(pressed_key + 4) = uVar1;
    if ((key_code &amp; 1) == 0) {
      return;
    }
  }
  uVar2 = s_Pressed_2_80390078._8_2_;
  uVar1 = s_Pressed_2_80390078._4_4_;
  *(undefined4 *)pressed_key = s_Pressed_2_80390078._0_4_;
  *(undefined4 *)(pressed_key + 4) = uVar1;
  *(undefined2 *)(pressed_key + 8) = uVar2;
  return;
}
</code></pre>
</details>
<h2><a class="header" href="#getting-the-flag" id="getting-the-flag">Getting the flag</a></h2>
<p>When tracing what gets printed onto the screen, we suspect heavily that the flag would be printed when the sequence of key presses are correct. We also suspect that the flag gets printed in the space of <code>No flag yet ...</code>. Tracking that ,), we see another usage of that variable, (refactored as <code>FLAG</code> , in one place which is &quot;sequence&quot; 9.</p>
<p>All we need to do is to move from sequence to sequence.</p>
<pre><code class="language-c">...
...
if (sequence == 9) {
        if ((key_code &amp; 0x800) != 0) {
          FLAG = (undefined4 *)&amp;local_a0; // &lt;- REACH HERE
          local_8e = local_5c._2_1_;
          local_90 = local_6c._0_1_;
        }
LAB_8003d8e4:
        if (sequence == 0) {
LAB_8003d8ec:
          sequence = 0;
          if ((key_code &amp; 8) != 0) {   // &lt;-- A PRESS
            sequence = 1;
            local_80 = (char)local_58;
            local_7e = local_78._1_1_ + ' ';
            local_81 = local_60._2_1_;
            local_a0 = (char)local_58 + -0x20;
            local_83 = local_70._0_1_;
          }
        }
      }
      else {
        if (sequence == 8) {
          if ((key_code &amp; 0x800) == 0) goto LAB_8003d8ec; // &lt;-- UP PRESS
          local_93 = local_58._2_1_;
          sequence = 9;
          local_98 = local_68._0_1_;
...
...

// Continue on and chain them up from sequence 0 to 9
</code></pre>
<p>After the quick trace, we see that we are supposed to press <code>&lt;A&gt;&lt;B&gt;&lt;RIGHT&gt;&lt;LEFT&gt;&lt;RIGHT&gt;&lt;LEFT&gt;&lt;DOWN&gt;&lt;DOWN&gt;&lt;UP&gt;&lt;UP&gt;</code></p>
<p>Trying that on the program and we flagged!</p>
<p><img src="writeups/service_revolution/img/serviceRevolutionFlag.png" alt="flag_service_revolution" /></p>
<h3><a class="header" href="#flag--alleswii_love_to_enter_great_flags" id="flag--alleswii_love_to_enter_great_flags">FLAG : ALLES{Wii_love_to_enter_great_flags}</a></h3>
<hr />
<h1><a class="header" href="#angr-ctf-1-basic-concepts---00_angr_find---01_angr_avoid" id="angr-ctf-1-basic-concepts---00_angr_find---01_angr_avoid">Angr-CTF #1 (Basic Concepts -&gt; 00_angr_find -&gt; 01_angr_avoid)</a></h1>
<hr />
<p><img src="writeups/angr/img/angrLogo.jpg" alt="angrLogo.jpg" /></p>
<p>This writeup attempts to start from the basic concepts in the first few challenges before getting more detailed in the later challenges.</p>
<h2><a class="header" href="#description-1" id="description-1"><strong>Description</strong></a></h2>
<p>Angr is a python framework that is used for binary analysis by combining both static and dynamic symbolic analysis. There are many usages of this framework including in CTFs like ROPChaining, SMT solving (z3 as backend) and others. For this post(s), it is meant to be a more detailed writeup on the challenges with reference to the angr API. You can find the challenges from <a href="https://github.com/jakespringer/angr_ctf">https://github.com/jakespringer/angr_ctf</a>. It includes the solution and scaffolds [ helper code structure ] to aid in learning angr.</p>
<p>You can view Angr's documentations from <a href="http://angr.io/api-doc/">http://angr.io/api-doc/</a></p>
<h2><a class="header" href="#what-is-symbolic-execution" id="what-is-symbolic-execution">What is Symbolic Execution</a></h2>
<h1><a class="header" href="#" id=""></a></h1>
<p>WIKIPEDIA SAYS:</p>
<blockquote>
<p>In computer science, symbolic execution (also symbolic evaluation or symbex) is a means of analyzing a program to determine what inputs cause each part of a program to execute. An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would. It thus arrives at expressions in terms of those symbols for expressions and variables in the program, and constraints in terms of those symbols for the possible outcomes of each conditional branch. </p>
</blockquote>
<p>This allows us to &quot;follow&quot; marked variables/registers/memory and see what changes during the execution of the program which makes it useful for binary analysis. Coupled with a SMT solver like Z3 solver, we can solve values based on constraints that can be added by the user based on the program's analysis.</p>
<hr />
<h2><a class="header" href="#installing-angr" id="installing-angr"><strong>Installing Angr</strong></a></h2>
<p>You can choose to install and setup a virtualenv be it a virtual machine or via python's <code>mkvirtualenv</code> command.</p>
<p>Installing angr via pip would be as easy as :</p>
<pre><code>pip install angr
</code></pre>
<p>For me, I am doing it in a ubuntu18 VM with python3 and relied mostly on the documentations and ipython3. You can install ipython3 via pip as well. What's amazing is that you can generate variants of the challenges with their generate.py file and it would generate c code before compiling it with GCC. For this writeups, I will be using the binary under the <code>dist</code> folder with IDA as our decompiler. You can choose to use Ghidra as well and their symbols should still be intact since these 32bits binaries are not stripped of their symbols.</p>
<hr />
<h2><a class="header" href="#00_angr_find" id="00_angr_find"><strong>00_angr_find</strong></a></h2>
<p>Since this is the first challenge, there will be a little more details on some of the components of Angr that I hope is sufficient to help us understand how to use the basics of Angr. There will be examples of usages of some of the key components which can also be lifted off the documentations. As we visit more challenges, only the critical part would be covered so bear with me for this first one.</p>
<h3><a class="header" href="#the-decompilation" id="the-decompilation"><strong>The decompilation</strong></a></h3>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  signed int i; // [esp+1Ch] [ebp-1Ch]
  char s1[9]; // [esp+23h] [ebp-15h]
  unsigned int v6; // [esp+2Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  printf(&quot;Enter the password: &quot;);
  __isoc99_scanf(&quot;%8s&quot;, s1);
  for ( i = 0; i &lt;= 7; ++i )
    s1[i] = complex_function(s1[i], i);
  if ( !strcmp(s1, &quot;JACEJGCS&quot;) )
    puts(&quot;Good Job.&quot;);
  else
    puts(&quot;Try again.&quot;);
  return 0;
}
</code></pre>
<p>The main function is short and simple. It gets the user input from stdin. It only requires 8 bytes as password and for each of teh eight characters, a <code>complex_function</code> is applied to it. At the end of the day, those manupulations should cause the <code>password</code> to be transformed into <code>JACEJGCS</code> before printing a good job message which is the goal of this exercise.</p>
<p>Let's check out the <code>complex_function</code>.</p>
<pre><code class="language-c">int __cdecl complex_function(signed int a1, int a2)
{
  if ( a1 &lt;= 64 || a1 &gt; 90 )
  {
    puts(&quot;Try again.&quot;);
    exit(1);
  }
  return (3 * a2 + a1 - 65) % 26 + 65;
}}
</code></pre>
<p>This complex function takes in two arguments. The first argument would be the <code>s[i]</code> which is the user's input at the i-th index and the second argument would be the i-index itself. It checks that they are ASCII printable characters before doing some sort of transformation to it, specifically <code>(3 * a2 + a1 - 65) % 26 + 65</code>, before returning that value.</p>
<h3><a class="header" href="#creating-new-project" id="creating-new-project"><strong>Creating new Project</strong></a></h3>
<p>To start, lets fire up ipython3 and import Angr. It might take a little while to import at first.</p>
<pre><code class="language-python">import angr
</code></pre>
<p>The next step would be to create a new project. Referencing <a href="http://angr.io/api-doc/">http://angr.io/api-doc/</a>, we can go to the <code>Project</code> to see what arguments are being accepted.</p>
<pre><code class="language-python">class angr.project.Project(thing, default_analysis_mode=None, ignore_functions=None, use_sim_procedures=True, exclude_sim_procedures_func=None, exclude_sim_procedures_list=(), arch=None, simos=None, engine=None, load_options: Dict[str, Any] = None, translation_cache=True, support_selfmodifying_code=False, store_function=None, load_function=None, analyses_preset=None, concrete_target=None, **kwargs)
</code></pre>
<p>also, according to document, any other additional keywords will be passed into the <code>cle.loader</code>. CLE refers to the binary loader that angr use to be placed into memory almost like how the binary would be loaded when the binary is being run. This also means that the arguments used in this following loader class can be placed into the Project arguments as a fast way to configure the project and the loader at the same time.</p>
<pre><code class="language-python">class cle.loader.Loader(main_binary, auto_load_libs=True, concrete_target=None, force_load_libs=(), skip_libs=(), main_opts=None, lib_opts=None, ld_path=(), use_system_libs=True, ignore_import_version_numbers=True, case_insensitive=False, rebase_granularity=1048576, except_missing_libs=False, aslr=False, perform_relocations=True, load_debug_info=False, page_size=1, preload_libs=(), arch=None)
</code></pre>
<p>For this binary, we can set the settings to its default and just passing in the <code>thing</code>, basically the path to the binary for the Project instantiation.</p>
<pre><code class="language-python">project = angr.Project(&quot;./00_angr_find&quot;)
</code></pre>
<h3><a class="header" href="#loader" id="loader"><strong>Loader</strong></a></h3>
<p>Learn more about the loader from <a href="https://docs.angr.io/core-concepts/loading">https://docs.angr.io/core-concepts/loading</a>. In short, cited from this site:</p>
<blockquote>
<p>The CLE loader (cle.Loader) represents an entire conglomerate of loaded binary objects, loaded and mapped into a single memory space. Each binary object is loaded by a loader backend that can handle its filetype (a subclass of cle.Backend). For example, cle.ELF is used to load ELF binaries.</p>
</blockquote>
<p>We can explore more with the loader.</p>
<pre><code>loader = project.loader
</code></pre>
<p><img src="writeups/angr/img/exploreLoader.jpg" alt="exploreLoader.jpg" /></p>
<p>Also, we can see the main object which reveals things like it's section, PLT, architecture and things like whether Position Independent Code is present.</p>
<pre><code>In [10]: mainobj.pic
Out[10]: False

In [11]: mainobj.arch
Out[11]: &lt;Arch X86 (LE)&gt;

In [12]: mainobj.plt
Out[12]: 
{'__gmon_start__': 134513728,
 '__isoc99_scanf': 134513712,
 '__libc_start_main': 134513696,
 '__stack_chk_fail': 134513648,
 'exit': 134513680,
 'printf': 134513632,
 'puts': 134513664,
 'strcmp': 134513616}
</code></pre>
<p>Also, we can just leave the loader as it is.</p>
<h3><a class="header" href="#the-solver-engine" id="the-solver-engine"><strong>The Solver Engine</strong></a></h3>
<p>In Angr, we can use &quot;mark&quot; things like variables, memory and registers. Angr uses <code>claripy</code> as backend for that purpose. Here, we can also use claripy as a frontend to Z3 to solve simple constraints. We can see the example at <a href="http://angr.io/api-doc/claripy.html">http://angr.io/api-doc/claripy.html</a>.</p>
<pre><code class="language-python">import claripy
a = claripy.BVS(&quot;sym_val&quot;, 32)
b = claripy.RotateLeft(a, 8)
c = b + 4
s = claripy.Solver()
s.add(c == 0x41424344)
assert s.eval(c, 1)[0] == 0x41424344
assert s.eval(a, 1)[0] == 0x40414243
</code></pre>
<p>When we work with claripy in angr, we can also use it to &quot;mark&quot; values at given state. In Agnr, the state is also referred to as <code>angr.sim_state.SimState</code> or just <code>SimState</code>. We can get a state via <code>project.factory</code>. <code>project.factory</code> contains several constructors for common object that are frequently used like getting basic blocks of code from a specified address and also states!</p>
<h3><a class="header" href="#states" id="states"><strong>States</strong></a></h3>
<p>There are several states that are available to get from the loaded binary and those states can be customized through arguments in those constructors.
The following table is lifted off from <a href="https://docs.angr.io/core-concepts/states">https://docs.angr.io/core-concepts/states</a></p>
<table><thead><tr><th>States</th><th>Description</th></tr></thead><tbody>
<tr><td>.blank_state()</td><td>Constructs 'blank state' with most of the data uninitialized.When accessing uninitialized data, an unconstrained symbolic value will be returned.</td></tr>
<tr><td>.entry_state()</td><td>constructs a state ready to execute at the main binary's entry point.</td></tr>
<tr><td>.full_init_state()</td><td>constructs a state that is ready to execute through any initializers that need to be run before the main binary's entry point, for example, shared library constructors or preinitializers.</td></tr>
<tr><td>.call_state()</td><td>constructs a state ready to execute a given function.</td></tr>
</tbody></table>
<p>For this binary, we only need to get the entry state.</p>
<details>
<summary>
Click here to see the help page for entry_state
</summary>
<pre><code>
In [16]: state = project.factory.entry_state?
Signature: project.factory.entry_state(**kwargs) -&gt; angr.sim_state.SimState
Docstring:
Returns a state object representing the program at its entry point. All parameters are optional.

:param addr:            The address the state should start at instead of the entry point.
:param initial_prefix:  If this is provided, all symbolic registers will hold symbolic values with names
                        prefixed by this string.
:param fs:              a dictionary of file names with associated preset SimFile objects.
:param concrete_fs:     boolean describing whether the host filesystem should be consulted when opening files.
:param chroot:          a path to use as a fake root directory, behaves similar to a real chroot. used only when
                        concrete_fs is set to True.
:param argc:            a custom value to use for the program's argc. May be either an int or a bitvector. If
                        not provided, defaults to the length of args.
:param args:            a list of values to use as the program's argv. May be mixed strings and bitvectors.
:param env:             a dictionary to use as the environment for the program. Both keys and values may be
                        mixed strings and bitvectors.
:return:                The entry state.
:rtype:                 SimState
File:      ~/.local/lib/python3.6/site-packages/angr/factory.py
Type:      method
</code></pre>
</details>
<p>Since we are not dealing with argc and argv, we can ignore those parameters. These will be especailly useful when we want to &quot;mark&quot; those values.</p>
<pre><code>In [18]: state = project.factory.entry_state()

In [19]: state
Out[19]: &lt;SimState @ 0x8048450&gt;
</code></pre>
<h3><a class="header" href="#simulation-manager" id="simulation-manager"><strong>Simulation Manager</strong></a></h3>
<p>Simulation Manager simulates the flow of the program. This also allows us to move from one state to the other starting from the state that we constructed at the beginning. It is also the primary interface in Angr for performing execution, simulation with states. For example, it allows you to step forward, filter, merge and move around as you wish. This simulation manager can contain several <code>staashes</code> of states. The default stash is known as  <code>active</code>.</p>
<pre><code>In [23]: simmgr = p.factory.simulation_manager?
Signature: p.factory.simulation_manager(thing:Union[List[angr.sim_state.SimState], angr.sim_state.SimState, NoneType]=None, **kwargs) -&gt; 'SimulationManager'
)
In [26]: simmgr = p.factory.simulation_manager(state)

In [27]: simmgr
Out[27]: &lt;SimulationManager with 1 active&gt;

In [28]: simmgr.active
Out[28]: [&lt;SimState @ 0x8048450&gt;]

In [29]: len(simmgr.active)
Out[29]: 1

In [30]: simmgr.active[0]
Out[30]: &lt;SimState @ 0x8048450&gt;

</code></pre>
<p>Here, we can start also access the state's register and memory as well. For example if we want to find the value of the instruction pointer.</p>
<pre><code>In [31]: initialstate = simmgr.active[0]
In [32]: initialstate.regs.eip
Out[32]: &lt;BV32 0x8048450&gt;
</code></pre>
<p>Now we can also start to explore the simulation manager more</p>
<p><img src="writeups/angr/img/simulationManager.jpg" alt="simulationManager.jpg" /></p>
<p>One very useful function that we can use is the <code>explore</code> function. This allows us to run the program and let the program explore the binary. </p>
<pre><code>In [34]: simmgr.explore?
Signature: simmgr.explore(stash='active', n=None, find=None, avoid=None, find_stash='found', avoid_stash='avoid', cfg=None, num_find=1, **kwargs)
Docstring:
Tick stash &quot;stash&quot; forward (up to &quot;n&quot; times or until &quot;num_find&quot; states are found), looking for condition &quot;find&quot;,
avoiding condition &quot;avoid&quot;. Stores found states into &quot;find_stash' and avoided states into &quot;avoid_stash&quot;.

The &quot;find&quot; and &quot;avoid&quot; parameters may be any of:

- An address to find
- A set or list of addresses to find
- A function that takes a state and returns whether or not it matches.

If an angr CFG is passed in as the &quot;cfg&quot; parameter and &quot;find&quot; is either a number or a list or a set, then
any states which cannot possibly reach a success state without going through a failure state will be
preemptively avoided.
File:      ~/.local/lib/python3.6/site-packages/angr/sim_manager.py
Type:      method
</code></pre>
<p>The one that we want to use is the find parameter. This allows us to state address(es) we want to find. To do that, we can go back to the disassembler to find an address that we want to hit.</p>
<p><img src="writeups/angr/img/00_findaddress.jpg" alt="00_findaddress.jpg" /></p>
<p>Here is what it might look like when you explore the address that we want to find.</p>
<pre><code>In [35]: find = 0x08048678

In [36]: simmgr.explore(find=find)
WARNING | 2020-09-09 22:30:05,106 | angr.state_plugins.symbolic_memory | The program is accessing memory or registers with an unspecified value. This could indicate unwanted behavior.
WARNING | 2020-09-09 22:30:05,107 | angr.state_plugins.symbolic_memory | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by:
WARNING | 2020-09-09 22:30:05,107 | angr.state_plugins.symbolic_memory | 1) setting a value to the initial state
...
...
...
Out[36]: &lt;SimulationManager with 1 active, 16 deadended, 1 found&gt;
</code></pre>
<p>We should now be able to see that there is one that is active and found. To see what is being found,</p>
<pre><code>In [40]: simmgr.found[0]
Out[40]: &lt;SimState @ 0x8048678&gt;
</code></pre>
<p>This means that there is a state where the program actually would hit that address that we desire which means that there is a satisfiable solution. Now all that we need to do is to dump the string that Angr wrote to the stdin. To do that, we will need to access the state and get the information about the os before dumping the string at the file descriptor.</p>
<pre><code>In [43]: import sys

In [44]: found = simmgr.found[0]

In [45]: found.posix.dumps(sys.stdin.fileno())
Out[46]: b'JXWVXRKX'
</code></pre>
<p>With that value being dumped out, we can now test that value. </p>
<h3><a class="header" href="#the-script" id="the-script"><strong>The Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys
# Create a new project with the following constructor
# The current default one is good enough for now
project = angr.Project(&quot;./00_angr_find&quot;)
# Construct the current state that we want to run from the main function
state = project.factory.entry_state()
# Construct our simulation manager based off the current state
simmgr = project.factory.simulation_manager(state)
# This is the address where the &quot;Good Job&quot; text would be printed out
find = 0x08048678
# Start the exploration to find the state whereby the input value would execute the selected find address
simmgr.explore(find=find)

if simmgr.found[0]:
    found = simmgr.found[0]
    print(&quot;Solution Found!&quot;)
    # print out the the stdin that angr has input and dump out the string from the file desciptor
    print(found.posix.dumps(sys.stdin.fileno()))
else:
    print(&quot;No solutions found! :&lt;&quot;)
</code></pre>
<p><img src="writeups/angr/img/00_solved.jpg" alt="00_solved.jpg" /></p>
<hr />
<h2><a class="header" href="#01_angr_avoid" id="01_angr_avoid"><strong>01_angr_avoid</strong></a></h2>
<p>This challenge aims to show us about the avoid address which we can specify for Angr so that it would know that it is going down the wrong path and should retry. Like the <code>find</code> argument, we can also add the <code>avoid</code> argument as well in the <code>explore</code> function. Now, let's begin.</p>
<p>As usual, I tried opening the binary in IDA however there is a message by IDA saying that there are more than 1000 nodes to be displayed on the screen and that it failed to decompile because the function is too big. I have also tried to open it in Ghidra but it will take a very long time as well.</p>
<pre><code>cexplr@ubuntu:~/angr/angr_ctf-master/01_angr_avoid$ ls -alh output.c
-rw-r--r-- 1 cexplr cexplr 834K Sep 10 00:22 output.c
</code></pre>
<p>Just form the disassembly in IDA and Ghidra, we see that there are many checks and many <code>avoid_me</code> functions being called as well. We can edit the <code>generate.py</code> file in the challenge files outside of the <code>dist</code> folder.</p>
<pre><code class="language-python"># This is the new generate.py file to store a sample c code into an output.c file
#!/usr/bin/env pypy
import sys, random, os, tempfile
from templite import Templite

def generate(argv):
  if len(argv) != 3:
    print 'Usage: pypy generate.py [seed] [output_file]'
    sys.exit()

  seed = argv[1]
  output_file = argv[2]

  random.seed(seed)

  description = ''
  with open(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'description.txt'), 'r') as desc_file:
    description = desc_file.read().encode('string_escape').replace('\&quot;', '\\\&quot;')

  random_list = [random.choice([True, False]) for _ in xrange(64)]

  template = open(os.path.join(os.path.dirname(os.path.realpath(__file__)), '01_angr_avoid.c.templite'), 'r').read()
  c_code = Templite(template).render(description=description, random_list=random_list)

  with tempfile.NamedTemporaryFile(delete=False, suffix='.c') as temp:
    temp.write(c_code)
    f = open(&quot;output.c&quot;,&quot;w&quot;)
    f.write(c_code)
    f.close()
    temp.seek(0)
    os.system('gcc -m32 -o ' + output_file + ' ' + temp.name)

if __name__ == '__main__':
  generate(sys.argv)

</code></pre>
<p>We see that the file is huge.</p>
<p>To figure out why, we can look at the <code>01_angr_avoid.c.templite</code> file. THis is the recursive part which keeps adding checks and for each time it calls itself, it would also add c code  which thus makes it a super long check.</p>
<pre><code class="language-python">${
import random, os
random.seed(os.urandom(8))
userdef_charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
userdef = ''.join(random.choice(userdef_charset) for _ in range(8))

def check_string_recursive(array0, array1, random_list, bit):
  if bit &lt; 0:
    write('maybe_good(%s, %s);' % (array0, array1))
  else:
    if random_list[0]:
      write('if (CHECK_BIT(%s, %d) == CHECK_BIT(%s, %d)) {' % (array0, bit, array1, bit))
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('} else { avoid_me(); ')
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('}')
    else:
      write('if (CHECK_BIT(%s, %d) != CHECK_BIT(%s, %d)) { avoid_me();' % (array0, bit, array1, bit))
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('} else { ')
      check_string_recursive(array0, array1, random_list[1:], bit-1)
      write('}')
}$
</code></pre>
<p>The output would look something like</p>
<pre><code class="language-c">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;

#define USERDEF &quot;UFWSAIZV&quot;
#define LEN_USERDEF 8

// return true if nth bit of array is 1
#define CHECK_BIT(array, bit_index) (!!(((uint8_t*) array)[bit_index / 8] &amp; (((uint8_t) 0x1) &lt;&lt; (bit_index % 8))))

char msg[] =
  &quot;placeholder\n&quot;;

uint8_t should_succeed = 1;

void print_msg() {
  printf(&quot;%s&quot;, msg);
}

int complex_function(int value, int i) {
#define LAMBDA 5
  if (!('A' &lt;= value &amp;&amp; value &lt;= 'Z')) {
    printf(&quot;Try again.\n&quot;);
    exit(1);
  }
  return ((value - 'A' + (LAMBDA * i)) % ('Z' - 'A' + 1)) + 'A';
}

void avoid_me() {
  should_succeed = 0;
}

void maybe_good(char* compare0, char* compare1) {
  if (should_succeed &amp;&amp; !strncmp(compare0, compare1, 8)) {
    printf(&quot;Good Job.\n&quot;);
  } else {
    printf(&quot;Try again.\n&quot;);
  }
}

int main(int argc, char* argv[]) {
  char buffer[20];
  char password[20];

  //print_msg();

  for (int i=0; i &lt; 20; ++i) {
    password[i] = 0;
  }

  strncpy(password, USERDEF, LEN_USERDEF);

  printf(&quot;Enter the password: &quot;);
  scanf(&quot;%8s&quot;, buffer);

  for (int i=0; i&lt;LEN_USERDEF; ++i) {
    buffer[i] = (char) complex_function(buffer[i], i);
  }

...
...
...
...
...
...
if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { 
    avoid_me();
    maybe_good(buffer, password);} 
else { maybe_good(buffer, password);}
} 
else { 
    if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { 
        avoid_me();
        maybe_good(buffer, password);
    } else { 
        maybe_good(buffer, password);}
    }} 
        else { if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}}} else { if (CHECK_BIT(buffer, 2) != CHECK_BIT(password, 2)) { avoid_me();if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}} else { if (CHECK_BIT(buffer, 1) != CHECK_BIT(password, 1)) { avoid_me();if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}} else { if (CHECK_BIT(buffer, 0) != CHECK_BIT(password, 0)) { avoid_me();maybe_good(buffer, password);} else { maybe_good(buffer, password);}}}}}}}}}}}}}

</code></pre>
<p>Here we can see that after the user has input the password, it would go throught a complex function for each character.  After the input has been transformed, monstrous amount of checks are being done and anytime a check fails, it would set <code>should_succeed</code> to 0 which is in the <code>avoid_me</code> function. Additionally, with that number of checks, it is really <del>impossible</del> tedious to reverse and find out what value it should be in the end. So let's begin writing a script in angr.</p>
<p>Note that we know that there are many <code>avoid_me</code> functions that we should , of course, avoid. We can get those address from the disassembler. </p>
<p><img src="writeups/angr/img/01_avoidme_functoin.jpg" alt="01_avoidme_functoin.jpg" /></p>
<p>We can also find the <code>maybe_good</code> function where the Good Job string would be printed.</p>
<p><img src="writeups/angr/img/01_maybegood_function.jpg" alt="01_maybegood_function.jpg" /></p>
<h3><a class="header" href="#writing-the-script" id="writing-the-script"><strong>Writing the Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys

# Create the project and load the binary
project = angr.Project(&quot;./01_angr_avoid&quot;)

# Create a state based on the current loaded binary
state = project.factory.entry_state()

# Construct the simulation manager set with the current state
simmgr = project.factory.simulation_manager(state)

# Find the address to find and avoid
find = 0x80485e5
avoid = 0x80485a8

# Start exploring different inputs and hopefully find the find function that we want
simmgr.explore(find=find,avoid=avoid)

# if there is a solution,
if simmgr.found[0]:
    print(&quot;found a solution&quot;)
    # Print out the input that Angr had found
    print(simmgr.found[0].posix.dumps(sys.stdin.fileno()))
else:
    print(&quot;No found solutions&quot;)
</code></pre>
<h3><a class="header" href="#test-the-solution" id="test-the-solution"><strong>Test the solution</strong></a></h3>
<p>Run and test the output if any</p>
<p><img src="writeups/angr/img/01_solved.jpg" alt="01_solved.jpg" /></p>
<hr />
<h1><a class="header" href="#angr-ctf-2-02_angr_find_condition---03_angr_symbolic_register---04_angr_symbolic_stack" id="angr-ctf-2-02_angr_find_condition---03_angr_symbolic_register---04_angr_symbolic_stack">Angr-CTF #2 [02_angr_find_condition -&gt; 03_angr_symbolic_register -&gt; 04_angr_symbolic_stack]</a></h1>
<hr />
<h2><a class="header" href="#description-2" id="description-2"><strong>Description</strong></a></h2>
<p>Welcome to part 2 of Angr-CTF post. This will be on a discussion on the next three challenges: <code>02_angr_find_condition</code> where we will learn to detect good or bad paths based on output strings, <code>03_angr_symbolic_registers</code> where we will &quot;mark&quot; registers and lastly <code>04_angr_symbolic_stack</code> where we will set up the stack in a blank state and exploring after the setup.</p>
<hr />
<h2><a class="header" href="#02_angr_find_condition" id="02_angr_find_condition"><strong>02_angr_find_condition</strong></a></h2>
<p>This exercise is to show us another usage of the <code>find</code> and <code>avoid</code> function.</p>
<pre><code> The &quot;find&quot; and &quot;avoid&quot; parameters may be any of:

- An address to find
- A set or list of addresses to find
- A function that takes a state and returns whether or not it matches
</code></pre>
<p>For this exercise, it will explore the use of those functions with afunction that takes a state and returns whether or not it matches. </p>
<p>This binary is still very similar and the only difference we will do for this exercise is to match a find when the stdout prints <code>Good Job</code> and a match to avoid when the stdout prints <code>Try again.</code>. Keep in mind that stdout is in bytes.</p>
<p>How this work is that time a state changes during an exploration, it would check the std output to check for that string. If none of the string matches, continue on. </p>
<p>We can come up with those two functions.</p>
<pre><code class="language-python">import angr
import sys

def success(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Good Job&quot; in stdout_str # Will return whether or not it matches
def fail(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Try again&quot; in stdout_str # Will return whether or not it matches
</code></pre>
<p>The next few steps should now be highly familiar to you at this moment so we shall just head straight into the full script and just adding those two functions as <code>find</code> and <code>avoid</code></p>
<h3><a class="header" href="#full-script" id="full-script"><strong>Full Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys

def success(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Good Job&quot; in stdout_str # Will return whether or not it matches
def fail(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Try again&quot; in stdout_str # Will return whether or not it matches

# Set up a project and load the binary
project = angr.Project(&quot;./02_angr_find_condition&quot;)
# Construct an entry state to be run from main
state = project.factory.entry_state()
# Construct a simulation manager with the initial state
simmgr = project.factory.simulation_manager(state)

# start exploring based on the function that accepts a state and returns whether or not it matches.
simmgr.explore(find=success,avoid=fail)
if simmgr.found[0]:
    print(&quot;Solution found!&quot;)
    print(simmgr.found[0].posix.dumps(sys.stdin.fileno()))
else:
    print(&quot;No solution found&quot;)

# UFOHHURD
</code></pre>
<p><img src="writeups/angr/img/02_solved.jpg" alt="02_solved.jpg" /></p>
<hr />
<h2><a class="header" href="#03_angr_symbolic_registers" id="03_angr_symbolic_registers"><strong>03_angr_symbolic_registers</strong></a></h2>
<p>For this challenge, it is a little more interesting. It will give us a taste of creating and initializing some components of a <code>blank_state</code> and three of its regsiters starting from a non-main function address.</p>
<p>Let's dive straight down into the decompilation.</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // ebx
  int v4; // eax
  int v5; // edx
  int v6; // ST1C_4
  unsigned int v7; // ST14_4
  unsigned int v9; // [esp+8h] [ebp-10h]
  unsigned int v10; // [esp+Ch] [ebp-Ch]

  printf(&quot;Enter the password: &quot;);
  v4 = get_user_input();
  v6 = v5;
  v7 = complex_function_1(v4);
  v9 = complex_function_2(v3);
  v10 = complex_function_3(v6);
  if ( v7 || v9 || v10 )
    puts(&quot;Try again.&quot;);
  else
    puts(&quot;Good Job.&quot;);
  return 0;
}
</code></pre>
<p>The main function seems a little weird. Firstly, we get some form of user input which there wil be three variables being put into different complex functions. What is strange is that there seem to be no references to this local variables which makes it an uninitialized variable. Later on, the result of the complex functions are then compared to make sure that they are 0 else it will fail. </p>
<details>
<summary>
Click here to see the decompilations of all three complex functions
</summary>
<pre><code class="language-c">unsigned int __cdecl complex_function_1(int a1)
{
  return (((((((((((((((((((((a1 + 17062705) ^ 0xB168C552) + 647103529) ^ 0x9F14CFD7) - 548738866) ^ 0xF78063EF)
                      - 1352480098) ^ 0x5D1F4C6)
                    - 57802472) ^ 0xB6F70BF8)
                  - 1347645151
                  + 648671421) ^ 0x3D5082FE)
                - 9365053) ^ 0xD0150EAD)
              + 1067946459) ^ 0xE6E03877)
            - 359192087
            + 961945065) ^ 0xE1EECD69)
          - 1817072919) ^ 0x6B86ECF5)
        - 449212884) ^ 0x2012CCDB;
}

unsigned int __cdecl complex_function_2(int a1)
{
  return (((((((((((((((((((((((((a1 + 488799652) ^ 0x5E3307AF) - 177708255) ^ 0xF4CE17EB) - 201900821) ^ 0x5258EFD1)
                          - 1211402798) ^ 0x25DB9B81)
                        - 1561143269
                        + 429947764) ^ 0xC8788683)
                      + 38428841) ^ 0x54FC78E8)
                    - 1037482775) ^ 0x42C3BC1E)
                  - 1210432369) ^ 0x72753AEA)
                + 627549795) ^ 0xD03DF7C8)
              - 105848572
              + 1068891943) ^ 0x9DF87491)
            + 514536287) ^ 0xE411081C)
          - 1559650067) ^ 0xCD5950F1)
        - 1664779985) ^ 0xC7340566;
}

unsigned int __cdecl complex_function_3(int a1)
{
  return ((((((((((((((((((a1 ^ 0xA6990438) - 1507377574 + 492465943) ^ 0x4C129858) - 1488446618) ^ 0x7D335ACB)
                    - 888160389) ^ 0xE856BBFB)
                  - 1014728623) ^ 0x30BC8744)
                - 315821521) ^ 0x97DEA993)
              + 1606484862) ^ 0x3FCFCEE1)
            + 240258290) ^ 0x97BB1E9F)
          - 769192860) ^ 0x571665D0)
        - 1220358966
        + 845065664) ^ 0xE61DCE92;
}
</code></pre>
</details>
<p>Let us take a look at the user input to figure out what is going on.</p>
<pre><code class="language-c">int get_user_input()
{
  int v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  unsigned int v4; // [esp+Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  __isoc99_scanf(&quot;%x %x %x&quot;, &amp;v1, &amp;v2, &amp;v3);
  return v1;
}
</code></pre>
<p>It seems like we are geting in three user inputs in <code>hexadecimal</code> form and storing into <code>get_user_input</code>'s local variables and returning just the first value, <code>v1</code>. Which does not make too much sense. However, this will get clarified when we dive into the disassembly.</p>
<pre><code class="language-asm">; int __cdecl main(int argc, const char **argv, const char **envp)
public main
main proc near

var_14= dword ptr -14h
var_10= dword ptr -10h
var_C= dword ptr -0Ch
var_4= dword ptr -4
argc= dword ptr  8
argv= dword ptr  0Ch
envp= dword ptr  10h

lea     ecx, [esp+4]
and     esp, 0FFFFFFF0h
push    dword ptr [ecx-4]
push    ebp
mov     ebp, esp
push    ecx
sub     esp, 14h
sub     esp, 0Ch
push    offset aEnterThePasswo ; &quot;Enter the password: &quot;
call    _printf
add     esp, 10h
call    get_user_input
mov     [ebp+var_14], eax  # This is the first value
mov     [ebp+var_10], ebx
mov     [ebp+var_C], edx
sub     esp, 0Ch
push    [ebp+var_14]          &lt;------- EAX
call    complex_function_1
add     esp, 10h
mov     ecx, eax
mov     [ebp+var_14], ecx
sub     esp, 0Ch
push    [ebp+var_10]          &lt;------- EBX
call    complex_function_2
add     esp, 10h
mov     ecx, eax
mov     [ebp+var_10], ecx
sub     esp, 0Ch
push    [ebp+var_C]             &lt;------- EDX
call    complex_function_3
add     esp, 10h
mov     ecx, eax
...
...
</code></pre>
<p>We can see that the values pushed are marked with <code>&lt;-------</code> and its registers. The corresponding registers are determined by finding where did  [ebx+var_???] gets written in the disassembly.</p>
<pre><code>mov     [ebp+var_14], eax  # This is the first value
mov     [ebp+var_10], ebx
mov     [ebp+var_C], edx
</code></pre>
<p>After that if we were to look into the disassembly of <code>get_user_input</code> function.</p>
<pre><code>push    ebp
mov     ebp, esp
sub     esp, 18h
mov     ecx, large gs:14h
mov     [ebp+var_C], ecx
xor     ecx, ecx
lea     ecx, [ebp+var_10] #The third address for scanf
push    ecx
lea     ecx, [ebp+var_14] # The second address of scanf 
push    ecx
lea     ecx, [ebp+var_18] # The first address of scanf 
push    ecx
push    offset aXXX     ; &quot;%x %x %x&quot;
call    ___isoc99_scanf
add     esp, 10h
mov     ecx, [ebp+var_18]  # first adderss of scanf 
mov     eax, ecx          &lt;------- eax value = first address of scanf
mov     ecx, [ebp+var_14]  # second address of scanf  
mov     ebx, ecx          &lt;------- ebx value = second address of scanf
mov     ecx, [ebp+var_10]  # third address of scanf 
mov     edx, ecx          &lt;------- edx value = third address of scanf
</code></pre>
<p>From this disassembly, values of registers eax,ebx and edx are being determined by scanf in the <code>get_user_input</code> function. </p>
<p>As a recap, remember that we can &quot;mark&quot; registers and those registers are stored in <code>SimStates</code>.</p>
<p>For example:</p>
<pre><code class="language-python">In [4]: state = p.factory.entry_state()

In [5]: state.regs.rax

In [6]: state.regs.eax
Out[6]: &lt;BV32 0x1c&gt;
</code></pre>
<h3><a class="header" href="#bitvectors" id="bitvectors"><strong>Bitvectors</strong></a></h3>
<p>Before attempting the challenge, we should understanding the basics of bitvectors.</p>
<p>According to <a href="https://docs.angr.io/core-concepts/solver#working-with-bitvectors">https://docs.angr.io/core-concepts/solver#working-with-bitvectors</a>,</p>
<blockquote>
<p>A bitvector is just a sequence of bits, interpreted with the semantics of a bounded integer for arithmetic. </p>
</blockquote>
<p>With this, we can now create symbolic variables which we want to &quot;mark&quot;. for instance,</p>
<pre><code class="language-python">In [10]: symbolName = state.solver.BVS(&quot;symbolName&quot;,32)

# We can also do mathematical equations with them
In [11]: symbolName + 2
Out[11]: &lt;BV32 symbolName_5_32 + 0x2&gt;

In [12]: symbolName /4 + symbolName
Out[12]: &lt;BV32 symbolName_5_32 / 0x4 + symbolName_5_32&gt;

</code></pre>
<p>However we should note that bitvector can only do math with those of the same bit length</p>
<pre><code class="language-python">In [14]: ninebit = state.solver.BVS(&quot;ninebit&quot;,9)

In [15]: ninebit + symbolName
---------------------------------------------------------------------------
ClaripyOperationError                     Traceback (most recent call last)
&lt;ipython-input-15-0d285337272a&gt; in &lt;module&gt;()
----&gt; 1 ninebit + symbolName

/home/cexplr/.local/lib/python3.6/site-packages/claripy/operations.py in _op(*args)
     48                 success, msg = extra_check(*fixed_args)
     49                 if not success:
---&gt; 50                     raise ClaripyOperationError(msg)
     51 
     52         #pylint:disable=too-many-nested-blocks

ClaripyOperationError: args' length must all be equal
</code></pre>
<p>We can solve that by either using <code>zero_extend</code> function which extending with zeros with the number of bits that you want to extend or the <code>sign_extend</code> to duplicate teh sign bits. The following example shows the usage of <code>zero_extend</code> function.</p>
<pre><code class="language-python">In [16]: ninebit.zero_extend?
Signature: ninebit.zero_extend(n)
Docstring:
Zero-extends the bitvector by n bits. So:

    a = BVV(0b1111, 4)
    b = a.zero_extend(4)
    b is BVV(0b00001111)
File:      ~/.local/lib/python3.6/site-packages/claripy/ast/bv.py
Type:      method

In [17]: ninebit.zero_extend(32-ninebit.length)
Out[17]: &lt;BV32 0#23 .. ninebit_6_9&gt;

In [18]: symbolName = symbolName + ninebit.zero_extend(32-ninebit.length)

In [19]: symbolName
Out[19]: &lt;BV32 symbolName_5_32 + (0#23 .. ninebit_6_9)&gt;
</code></pre>
<p>Apart from Bit Vector Symbols (BVS), we can also add Bit Vector Values(BVV). We can for example create a 32 bit number of the value 10.</p>
<pre><code class="language-python">In [20]: value10 = state.solver.BVV(10,32)

In [21]: value10
Out[21]: &lt;BV32 0xa&gt;
...
...
In [24]: value10 + 20
Out[24]: &lt;BV32 0x1e&gt;
</code></pre>
<p>Note that those values being returned are ASTs AKA Bitvectors.</p>
<h3><a class="header" href="#solution" id="solution"><strong>Solution</strong></a></h3>
<p>Now that we know what bitvectors are, we can start to solve the challenge. For this challenge, the given scaffold hints us to use a blank_state. This state allows us to choose from which address we want to start from and set the register values once we construct the state. We establish the fact that the three passwords are needed and those registers containing the input would be send into their respective complex functions. Once the three of them passes the complex function, we would succeed otherwise we fail.  The registers containing the first, second and third passwords are eax, ebx and edx respectively.</p>
<p>First we can create a blank state and to do that we can choose the address that we want to start with. </p>
<pre><code>In [4]: blank_state = project.factory.blank_state?
Signature: project.factory.blank_state(**kwargs)
Docstring:
Returns a mostly-uninitialized state object. All parameters are optional.

:param addr:            The address the state should start at instead of the entry point.
:param initial_prefix:  If this is provided, all symbolic registers will hold symbolic values with names
                        prefixed by this string.
:param fs:              A dictionary of file names with associated preset SimFile objects.
:param concrete_fs:     bool describing whether the host filesystem should be consulted when opening files.
:param chroot:          A path to use as a fake root directory, Behaves similarly to a real chroot. Used only
                        when concrete_fs is set to True.
:param kwargs:          Any additional keyword args will be passed to the SimState constructor.
:return:                The blank state.
:rtype:                 SimState
File:      ~/.local/lib/python3.6/site-packages/angr/factory.py
Type:      method

</code></pre>
<p>Here, since we know how the userinput would get its value (i.e. through the three registers), we can essentially skip the <code>get_user_input</code> function and just start from after the function returns. Finally, we also know that three registers should contain integers making it a 32 bit value. Once those are done, we can start to simulate the state and explore. If a solution is found, evaluate those BVS and convert them back to hexadecimal values.</p>
<p><img src="writeups/angr/img/03_start_address.jpg" alt="03_start_address.jpg" /></p>
<pre><code class="language-python">import angr
import sys

project = angr.Project(&quot;./03_angr_symbolic_registers&quot;)
start_address = 0x8048980
state = project.factory.blank_state(addr=start_address)

# Three BVS that we want to mark
pass0 = state.solver.BVS(&quot;pass0&quot;,32)
pass1 = state.solver.BVS(&quot;pass1&quot;,32)
pass2 = state.solver.BVS(&quot;pass2&quot;,32)

# Set up the current state register at the start address thus &quot;marking&quot; them
state.regs.eax = pass0
state.regs.ebx = pass1
state.regs.edx = pass2

# Construct the simulation manager with the newly initialized state
simmgr = project.factory.simulation_manager(state)

# Explore with the same functions that are used since they are the same as the 02_angr_find_condition

def success(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Good Job&quot; in stdout_str # Will return whether or not it matches
def fail(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Try again&quot; in stdout_str # Will return whether or not it matche

# explore
simmgr.explore(find=success, avoid=fail)
found_state = &quot;&quot;
if simmgr.found[0]:
    # Store the found state for easier evaluation of symbols
    found_state = simmgr.found[0]
    print(&quot;Solution found!&quot;)
    # Evaluate all the values and note that those values are in integers
    pass0 = found_state.solver.eval(pass0)
    pass1 = found_state.solver.eval(pass1)
    pass2 = found_state.solver.eval(pass2)
    # Convert from integer to hexadecimal and print it out
    print(&quot;%x %x %x&quot;,format(pass0,pass1,pass2))
else:
    print(&quot;No found solution :(&quot;)
</code></pre>
<p>Running it and testing it we should get the result!</p>
<p><img src="writeups/angr/img/03_solved.jpg" alt="03_solved.jpg" /></p>
<hr />
<h2><a class="header" href="#04_angr_symbolic_stack" id="04_angr_symbolic_stack"><strong>04_angr_symbolic_stack</strong></a></h2>
<p>For this challenge, the function that we are more interested in is the <code>handle_user</code> function </p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  printf(&quot;Enter the password: &quot;);
  handle_user();
  return 0;
}
</code></pre>
<p>Here is the decompilation of the <code>handle_user</code> function.</p>
<pre><code class="language-c">int handle_user()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]

  __isoc99_scanf(&quot;%u %u&quot;, &amp;v2, &amp;v1);
  v2 = complex_function0(v2);
  v1 = complex_function1(v1);
  if ( v2 == 0x773024D1 &amp;&amp; v1 == 0xBC4311CF )
    result = puts(&quot;Good Job.&quot;);
  else
    result = puts(&quot;Try again.&quot;);
  return result;
}
</code></pre>
<p>Unlike the previous challenge, this time we can tell where the values are stored in right from the decompilation without looking at the disassembly. Those values are stored in the memory in the stack frame. This means that we can now attempt to create symbolic stack memory where the values would be passed into the complex functions. Like the previous, challenge, we can create a blank_state with a custom start address; start address can be after the scanf function call.</p>
<h3><a class="header" href="#which-start-address" id="which-start-address"><strong>Which Start Address?</strong></a></h3>
<p>For this, we should take a look at the disassembler. </p>
<pre><code>text:08048679                 public handle_user
.text:08048679 handle_user     proc near               ; CODE XREF: main+21âp
.text:08048679
.text:08048679 var_10          = dword ptr -10h
.text:08048679 var_C           = dword ptr -0Ch
.text:08048679
.text:08048679 ; __unwind {
.text:08048679                 push    ebp
.text:0804867A                 mov     ebp, esp
.text:0804867C                 sub     esp, 18h
.text:0804867F                 sub     esp, 4
.text:08048682                 lea     eax, [ebp+var_10]
.text:08048685                 push    eax
.text:08048686                 lea     eax, [ebp+var_C]
.text:08048689                 push    eax
.text:0804868A                 push    offset aUU      ; &quot;%u %u&quot;
.text:0804868F                 call    ___isoc99_scanf
.text:08048694                 add     esp, 10h           &lt;-----this clears the variable for the two inputs as part of housekeeping since scanf is not completed
.text:08048697                 mov     eax, [ebp+var_C]
.text:0804869A                 sub     esp, 0Ch
.text:0804869D                 push    eax
.text:0804869E                 call    complex_function0
.text:080486A3                 add     esp, 10h
.text:080486A6                 mov     [ebp+var_C], eax
.text:080486A9                 mov     eax, [ebp+var_10]
...
...
</code></pre>
<p>Since this is following the <code>cdecl</code> calling convention</p>
<p>According to wikipedia,</p>
<blockquote>
<p>The cdecl (which stands for C declaration) is a calling convention that originates from Microsoft's compiler for the C programming language and is used by many C compilers for the x86 architecture.[1] In cdecl, subroutine arguments are passed on the stack. Integer values and memory addresses are returned in the EAX register, floating point values in the ST0 x87 register. Registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved.</p>
</blockquote>
<p>Since the caller would do the clean up which is what is happening at <code>0x08048694</code>, we will want to create a blank state from the address after this, <code>0x08048697</code> instead.</p>
<pre><code class="language-python">state = project.factory.blank_state(addr=0x08048697)
</code></pre>
<h3><a class="header" href="#stack-operations" id="stack-operations"><strong>Stack operations</strong></a></h3>
<p>There are three important stack function. They are <code>stack_pop</code>,<code>stack_push</code> and <code>stack_read</code>. </p>
<p>The following is the dump from the documentation.</p>
<pre><code>In [24]: state.stack_push?
Signature: state.stack_push(thing)
Docstring: Push 'thing' to the stack, writing the thing to memory and adjusting the stack pointer.
File:      ~/.local/lib/python3.6/site-packages/angr/sim_state.py
Type:      method


In [25]: state.stack_pop?
Signature: state.stack_pop()
Docstring: Pops from the stack and returns the popped thing. The length will be the architecture word size.
File:      ~/.local/lib/python3.6/site-packages/angr/sim_state.py
Type:      method


In [27]: state.stack_read?
Signature: state.stack_read(offset, length, bp=False)
Docstring:
Reads length bytes, at an offset into the stack.

:param offset:  The offset from the stack pointer.
:param length:  The number of bytes to read.
:param bp:      If True, offset from the BP instead of the SP. Default: False.
File:      ~/.local/lib/python3.6/site-packages/angr/sim_state.py
Type:      method

</code></pre>
<h3><a class="header" href="#setting-up-the-blank-state" id="setting-up-the-blank-state"><strong>Setting up the blank state</strong></a></h3>
<p>For this challenge, we will need to create a symbolic stack for the password inputs specifically for the following. However, there is a catch. Since we want to make a symbolic stack and that we are jumping into the middle of the function, we need to account and make sure that the stack setup is correct or else values in registers and memory might be initialized wrongly giving false result. The following is taken from the disassembly.</p>
<pre><code class="language-c">  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
</code></pre>
<p>We know that the two user inputs are unsigned integers and that they take up 4 bytes in the stack memory. </p>
<p>For this, start off by also simulating the formulation of the stack frame </p>
<pre><code class="language-python">state.regs.ebp = state.regs.esp
</code></pre>
<p>Next, make the <code>esp</code> point to the proper location (via subtraction) Since <code>v2</code> starts at offset <code>ebp-0xc</code>, we can do that by subtracting the <code>esp</code> which contains the same value as <code>ebp</code> at the moment. Remember to subtract the length of 4 bytes since <code>int</code> contains 4 bytes.</p>
<pre><code class="language-python">state.regs.esp -= (0xc-4)
</code></pre>
<p>Finally, pushing 2 bitvectors with <code>state.stack_push</code> function onto the stack. Pushing the bitvector on the stack would change the value of the esp naturally.</p>
<pre><code class="language-python">pass0 = state.solver.BVS(&quot;pass0&quot;,32)
pass1 = state.solver.BVS(&quot;pass1&quot;,32)
state.stack_push(pass0)
state.stack_push(pass1)
</code></pre>
<p>Once, we are done, we have completed the initialization of the state's stack. With this in mind, we can start to create a script to do these.</p>
<h3><a class="header" href="#the-script-1" id="the-script-1"><strong>The Script</strong></a></h3>
<pre><code class="language-python">import angr
import sys

# Create a new project
project = angr.Project(&quot;./04_angr_symbolic_stack&quot;)
# Construct the state after the clean up of the scanf function
state = project.factory.blank_state(addr=0x08048697)

# Set the state's stack to model after the completion of the scanf function
state.regs.ebp = state.regs.esp # The start of the new stack frame
state.regs.esp -= (0xc-4) # Adding the padding till the location of the first password location
# Create the bitvectors for the password the size of an integer
pass0 = state.solver.BVS(&quot;pass0&quot;,32)
pass1 = state.solver.BVS(&quot;pass1&quot;,32)

# push the two bitvector like it would be in the actual program
state.stack_push(pass0)
state.stack_push(pass1)

# Construct the simulation manager with the current state
simmgr = project.factory.simulation_manager(state)

def success(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Good Job&quot; in stdout_str # Will return whether or not it matches
def fail(curr_state):
    # Get the value of the stdout at the current state
    stdout_str = curr_state.posix.dumps(sys.stdout.fileno())
    return b&quot;Try again&quot; in stdout_str # Will return whether or not it matche

# Explore for a result
simmgr.explore(find=success, avoid=fail)
if simmgr.found[0]:
    print(&quot;Found a solution&quot;)
    foundstate = simmgr.found[0]
    print(foundstate.solver.eval(pass0))
    print(foundstate.solver.eval(pass1))
else:
    print(&quot;Cannot find solution&quot;)
 
</code></pre>
<p><img src="writeups/angr/img/04_solved.jpg" alt="04_solved.jpg" /></p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
